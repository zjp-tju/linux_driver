## 嵌入式协议总线 - HQ

[TOC]

------

#### 注意

- overview  概述
- cs 高电平有效，cs 上面有一横杠，低电平有效

------

## 可参考文章

- 公众号博主整理（两篇已整理，其余未整理） 
  - [SPI](http://www.linuxer.vip/i2c-bus-spec2/)
  - [I2C](http://www.linuxer.vip/i2c-bus-spec2/)
- CSDN大佬整理
  - [Linux SPI总线和设备驱动架构之四：SPI数据传输的队列化](https://blog.csdn.net/DroidPhone/article/details/24663659)
  - [Linux SPI总线和设备驱动架构之三：SPI控制器驱动](https://blog.csdn.net/DroidPhone/article/details/24353293)
  - [Linux SPI总线和设备驱动架构之二：SPI通用接口层](https://blog.csdn.net/DroidPhone/article/details/23932447)
  - [Linux SPI总线和设备驱动架构之一：系统概述](https://blog.csdn.net/DroidPhone/article/details/23367051) 





## 协议对比

#### I2C与SPI对比

常用的通信协议莫过于 I2C 和 SPI，他们的速率如下： 

- I2C 速率： 
  - 标准：100KHz 
  - 快速：400KHz 
  - 快速+：1MHz 
  - 高速：3.4MHz 
- SPI 速率： 几十 MHz 甚至上百 MHz，速度取决于 CPU的 SPI 控制器和时钟 clock 
  - STM32F103 的 SPI 最高支持 18MHz，imx6ull 的 SPI 最高支持 52MHz，其他芯片一般用不到更高的。 
  - 具体采用多大速率还和外设有关，比如EEPROM 的 W25Q128 的 SPI 最高支持80MHz，ICM20608 传感器的 SPI 最高支持8MHz。 

因此，I2C 多用来传输命令，SPI 多用来传输数据。





## 通信基础

**并行**

- 一次发送8位。

- 缺点，浪费资源，布线难度大，线之间有干扰，传输距离近。
- <img src="assets/image-20220316084254611.png" alt="image-20220316084254611" style="zoom:50%;" />



**串行**

- 一位一位发送。
- <img src="assets/image-20220316084328379.png" alt="image-20220316084328379" style="zoom:50%;" />



**单工通信**

- 发送方向是单向的。
- ![image-20220316084610787](assets/image-20220316084610787.png)



**双工通信**

- 半双工，只有一根线，同时只能一方收发。
- 全双工，有两根线，可以同时收发。
- <img src="assets/image-20220316084634091.png" alt="image-20220316084634091" style="zoom:67%;" />



**比特率（下面也是比特率）** 

- ![image-20220316084903407](assets/image-20220316084903407.png)



**同步**

- 有同步时钟，发送数据一方和接手数据一方同步，这样没有累积误差



**异步**

- 发送数据一方和接手数据一方不同步







## UART 通用异步收发器

1. 简介：

   - 串行，异步，全双工总线

   > ![image-20220316083903947](assets/image-20220316083903947.png)

2. 特点：

   - 在嵌入式领域，使用最多的通讯协议
   - **规定数据空闲的时候必须发高电平，所以起始位为低电平**
   - 停止位、空闲位都是高电平
   - **串口协议里规定，发送数据时，先发低位，再发高位 (队列FIFOs，先进先出)**
   - 串口通过波特率来“掐时间”，从而确定具体发了几个位
   - 为什么串口一次只能发5-8位数据，为了防止时间上的累计误差，这样再次发送的时候就会重新计时

3. UART存在的问题  (一般做项目很少使用串口通讯)  （3米左右就不能用了）

   - > ![image-20220316150333461](assets/image-20220316150333461.png)
      >
      > ![image-20220316151637963](assets/image-20220316151637963.png)

4. 通信原理

   > ![image-20220316084946381](assets/image-20220316084946381.png)
   >
   > ![image-20220316102535608](assets/image-20220316102535608.png)

5. 串口工作原理 及 硬件结构

   > ![image-20220316094613118](assets/image-20220316094613118.png)
   >
   > <img src="assets/image-20220316094819865.png" alt="image-20220316094819865" style="zoom:80%;" />

6. 硬件连接，串行，异步，全双工

   - > ![image-20220316090806079](assets/image-20220316090806079.png)

   - UART如图右侧COM3，SP3232芯片的作用是对信号提示，将TTL信号转为232信号，提升传输距离。

     > ![image-20220316092759682](assets/image-20220316092759682.png)

   - 引脚功能设置

     > ![image-20220316093145233](assets/image-20220316093145233.png)

7. UART控制器 & 内部寄存器

   > ![image-20220316091103349](assets/image-20220316091103349.png)
   >
   > <img src="assets/image-20220316102300698.png" alt="image-20220316102300698" style="zoom:80%;" />

8. CPU 读取 串口接收数据的方式

   - 轮训(polling)，cpu不断检测串口是否接收到数据，最低效。

     - 为了解决轮训时，串口发送的速度跟不上cpu写的速度，通过配置指示串口是否为空的寄存器来控制cpu的写入时机

     - > ![image-20220316113920270](assets/image-20220316113920270.png)

   - 中断，串口接收数据后主动提示cpu，较高效。

   - DMA，串口接收数据后直接访问存储器进行存储。

     - > <img src="assets/image-20220316103902252.png" alt="image-20220316103902252" style="zoom:50%;" />

9. UART 实操编程

   1. 输入输出重定向

      - `ls`  操作系统处理 ——> 显卡 ——> 屏幕显示

      - `ls > out.txt`  操作系统处理 ——> 磁盘 ——> 写入文件

   2. 此处的printf 输出重定向

      - 原来的`printf`  ——> 显示器显示

      - 现在的 `printf` ——>  UART串口打印

   3. 案例：linux 系统启动提示，输入输出错误打印都是通过串口

      > <img src="assets/image-20220316145351576.png" alt="image-20220316145351576" style="zoom:50%;" />

   4. ```cpp
      
      #include "exynos_4412.h"
      
      void UART_Init(void)
      {
      	/*1.将GPA1_0和GPA1_1设置成UART2的接收和发送引脚 GPA1CON[7:0]*/
          // & (~(0xFF << 0)) 把需要用的低8位清零
      	GPA1.CON = GPA1.CON & (~(0xFF << 0)) | (0x22 << 0);
      	/*2.设置UART2的帧格式 8位数据位 1位停止位 无校验 正常模式 ULCON2[6:0]*/
          // & (~(0X7F << 0)) 把需要用到的低7位清零
      	UART2.ULCON2 = UART2.ULCON2 & (~(0x7F << 0)) | (0x3 << 0);
      	/*3.设置UART2的接收和发送模式为轮询模式 UCON2[3:0]*/
      	UART2.UCON2 = UART2.UCON2 & (~(0xF << 0)) | (0x5 << 0);
      	/*4.设置UART2的波特率为115200 UBRDIV2/UFRACVAL2*/
          //参考芯片手册计算公式，(100000000/(115200)*16) - 1 = 53.25
      	UART2.UBRDIV2 = 53;
          //小数部分 * 16
      	UART2.UFRACVAL2 = 4;
      }
      
      void UART_Send_Byte(char Dat)
      {
      	/*等待发送寄存器为空，即上一个数据已经发送完成 UTRSTAT2[1]*/
      	while(!(UART2.UTRSTAT2 & (1 << 1)));
      	/*将要发送的数据写入发送寄存器 UTXH2*/
      	UART2.UTXH2 = Dat;
      }
      
      char UART_Rec_Byte(void)
      {
      	char Dat = 0;
      	/*判断接收寄存器是否接收到了数据 UTRSTAT2[0]*/
      	if(UART2.UTRSTAT2 & 1)
      	{
      		/*从接收寄存器中读取接收到的数据 URXH2*/
      		Dat = UART2.URXH2;
      		return Dat;
      	}
      	else
      	{
      		return 0;
      	}
      }
      
      //让串口输出一个字符串
      void UART_Send_Str(char *pstr)
      {
      	while(*pstr != '\0')  //字符串结束
      		UART_Send_Byte(*pstr++);  //每发完一个字符，指针++
      }
      
      int main()
      {
      	char RecDat = 0;
      	UART_Init();
      
      	while(1)
      	{
      		/*
      		RecDat = UART_Rec_Byte();
      		if(RecDat == 0)
      		{
      			
      		}
      		else
      		{
      			RecDat = RecDat + 1;
      			UART_Send_Byte(RecDat);
      		}
      		*/
      		
      		/*
      		UART_Send_Str("Hello World\n");
      		*/
      
      		printf("Hello World\n");  //此printf()为自己定义的函数，详细代码见课程程序
      	}
      	return 0;
      }
      
      ```

      




## RS232 总线协议

1. RS232 简介

   - > ![image-20220316151910929](assets/image-20220316151910929.png)
     >
     > ![image-20220316152044945](assets/image-20220316152044945.png)

2. 电平转换

   - > 这种方式为纯硬件层面的转换，编程不受影响
     >
     > ![image-20220316152938284](assets/image-20220316152938284.png)

3. RS232 存在的问题

   - > ![image-20220316154604530](assets/image-20220316154604530.png)





## RS485 总线协议

1. RS485 简介 （多站能力，可以挂载多个设备 <32个>，1500米），==两线制的485是半双工==

   - RS485 没有规定主从机的通讯机制，可以参考 IIC 规定的主从通讯机制

   - > ![image-20220316154916452](assets/image-20220316154916452.png)

   - > ![image-20220316155222432](assets/image-20220316155222432.png)

   - > ![image-20220316163016199](assets/image-20220316163016199.png)

2. 电平转换

   - > ![image-20220316163454519](assets/image-20220316163454519.png)

3. RS485 优点

   - > ![image-20220316163920728](assets/image-20220316163920728.png)





## IIC总线

1. IIC 总线简介 （串行，半双工，近距离）（由于收发双方用的是同一个时钟基准，所以一次可以发送任意多个字节）

   - > ![image-20220316194706544](assets/image-20220316194706544.png)

   - > ![image-20220316195029723](assets/image-20220316195029723.png)

2. IIC 总线通信过程

   - > 后续字节的传送方向：主机发送给从机  或者  从机发送给主机
     >
     > 4,5步发送数据的过程中不允许改变数据的传送方向
     >
     > 通信的起始信号和停止信号都是由主机发出
     >
     > ![image-20220316195821843](assets/image-20220316195821843.png)

   - 起始信号和停止信号

     > ![image-20220316201558921](assets/image-20220316201558921.png)

   - 字节传送与应答 ==（规定每个字节必须是8位，且先传送高位，后传送低位）==

     > ![image-20220316201816665](assets/image-20220316201816665.png)

   - 同步信号（告诉发送器什么时候发（低电平），告诉接收器什么时候收（高电平））

     > ![image-20220316202139258](assets/image-20220316202139258.png)

3. IIC 总线的寻址方式

   - > ![image-20220316201124410](assets/image-20220316201124410.png)

4. 典型 IIC 时序

   - > ![image-20220316204348595](assets/image-20220316204348595.png)

   - 第一次通讯结束时，主机重新发起始信号，再次建立连接，这期间主机没有发终止信号，避免再次建立连接时被其他抢走通讯。

     > ![image-20220316204651248](assets/image-20220316204651248.png)

5. IIC 手册

   - 特性

     > ![image-20220317091638264](assets/image-20220317091638264.png)

   - 寄存器

     > ![image-20220317091714599](assets/image-20220317091714599.png)

   - 工作逻辑框图

     > ![image-20220317092014993](assets/image-20220317092014993.png)

   - 主机/发送器 流程图

     > <img src="assets/image-20220317092513721.png" alt="image-20220317092513721" style="zoom:67%;" />

   - 主机/接收器 流程图

     > <img src="assets/image-20220317093233366.png" alt="image-20220317093233366" style="zoom:67%;" />

6. IIC 寄存器

   - 总览表

     > ![image-20220317093951944](assets/image-20220317093951944.png)

   - 单个寄存器的结构表

     > ![image-20220317094325660](assets/image-20220317094325660.png)


7. MPU6050 原理 （进行IIC 实验通信的芯片）

   - 介绍

     > ![image-20220317102541935](assets/image-20220317102541935.png)

   - 主要参数

     > ![image-20220317102843065](assets/image-20220317102843065.png)

   - 通讯接口

     > ![image-20220317102907356](assets/image-20220317102907356.png)

8. MPU6050 芯片手册

   - > ![image-20220317142303153](assets/image-20220317142303153.png)
   
   - > ![image-20220317142722727](assets/image-20220317142722727.png)

9. MPU6050 寄存器读写实验

   - 向芯片寄存器写一个字节的流程

     > ![image-20220317145115996](assets/image-20220317145115996.png)

   - 从芯片寄存器读一个字节的流程

     > ![image-20220317145645093](assets/image-20220317145645093.png)

   - ```cpp
     
     #include "exynos_4412.h"
     
     /****************MPU6050内部寄存器地址****************/
     
     #define	SMPLRT_DIV		0x19	//陀螺仪采样率，典型值：0x07(125Hz)
     #define	CONFIG			0x1A	//低通滤波频率，典型值：0x06(5Hz)
     #define	GYRO_CONFIG		0x1B	//陀螺仪自检及测量范围，典型值：0x18(不自检，2000deg/s)
     #define	ACCEL_CONFIG	0x1C	//加速计自检、测量范围及高通滤波频率，典型值：0x18(不自检，2G，5Hz)
     #define	ACCEL_XOUT_H	0x3B
     #define	ACCEL_XOUT_L	0x3C
     #define	ACCEL_YOUT_H	0x3D
     #define	ACCEL_YOUT_L	0x3E
     #define	ACCEL_ZOUT_H	0x3F
     #define	ACCEL_ZOUT_L	0x40
     #define	TEMP_OUT_H		0x41
     #define	TEMP_OUT_L		0x42
     #define	GYRO_XOUT_H		0x43
     #define	GYRO_XOUT_L		0x44
     #define	GYRO_YOUT_H		0x45
     #define	GYRO_YOUT_L		0x46
     #define	GYRO_ZOUT_H		0x47
     #define	GYRO_ZOUT_L		0x48
     #define	PWR_MGMT_1		0x6B	//电源管理，典型值：0x00(正常启用)
     #define	WHO_AM_I		0x75	//IIC地址寄存器(默认数值0x68，只读)
     #define	SlaveAddress	0x68	//MPU6050-I2C地址
     
     /************************延时函数************************/
     
     void mydelay_ms(int time)
     {
     	int i,j;
     	while(time--)
     	{
     		for(i=0;i<5;i++)
     			for(j=0;j<514;j++);
     	}
     }
     
     /**********************************************************************
      * 函数功能：I2C向特定地址写一个字节
      * 输入参数：
      * 		slave_addr： I2C从机地址
      * 			  addr： 芯片内部特定地址
      * 			  data：写入的数据
     **********************************************************************/
     
     void iic_write (unsigned char slave_addr, unsigned char addr, unsigned char data)
     {
     	/*对时钟源进行512倍预分频  打开IIC中断（每次完成一个字节的收发后中断标志位会自动置位）*/
     	I2C5.I2CCON = I2C5.I2CCON | (1<<6) | (1<<5);
     
     	/*设置IIC模式为主机发送模式  使能IIC发送和接收*/
     	I2C5.I2CSTAT = 0xd0;
     	/*将第一个字节的数据写入发送寄存器  即从机地址和读写位（MPU6050-I2C地址+写位0）*/
     	I2C5.I2CDS = slave_addr<<1;
     	/*设置IIC模式为主机发送模式  发送起始信号启用总线  使能IIC发送和接收*/
     	I2C5.I2CSTAT = 0xf0;
     
     	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
     	while(!(I2C5.I2CCON & (1<<4)));
     
     	/*将要发送的第二个字节数据（即MPU6050内部寄存器的地址）写入发送寄存器*/
     	I2C5.I2CDS = addr;
     	/*清除中断挂起标志位  开始下一个字节的发送*/
     	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
     	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
     	while(!(I2C5.I2CCON & (1<<4)));
     
     	/*将要发送的第三个字节数据（即要写入到MPU6050内部指定的寄存器中的数据）写入发送寄存器*/
     	I2C5.I2CDS = data;
     	/*清除中断挂起标志位  开始下一个字节的发送*/
     	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
     	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
     	while(!(I2C5.I2CCON & (1<<4)));
     
     	/*发送停止信号  结束本次通信*/
     	I2C5.I2CSTAT = 0xD0;
     	/*清除中断挂起标志位*/
     	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
     	/*延时*/
     	mydelay_ms(10);
     }
     
     /**********************************************************************
      * 函数功能：I2C从特定地址读取1个字节的数据
      * 输入参数：         slave_addr： I2C从机地址
      * 			       addr： 芯片内部特定地址
      * 返回参数： unsigned char： 读取的数值
     **********************************************************************/
     
     unsigned char iic_read(unsigned char slave_addr, unsigned char addr)
     {
     
     	unsigned char data = 0;
     
     	/*对时钟源进行512倍预分频  打开IIC中断（每次完成一个字节的收发后中断标志位会自动置位）*/
     	I2C5.I2CCON = I2C5.I2CCON | (1<<6) | (1<<5);
     
     	/*设置IIC模式为主机发送模式  使能IIC发送和接收*/
     	I2C5.I2CSTAT = 0xd0;
     	/*将第一个字节的数据写入发送寄存器  即从机地址和读写位（MPU6050-I2C地址+写位0）*/
     	I2C5.I2CDS = slave_addr<<1;
     	/*设置IIC模式为主机发送模式  发送起始信号启用总线  使能IIC发送和接收*/
     	I2C5.I2CSTAT = 0xf0;
     	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
     	while(!(I2C5.I2CCON & (1<<4)));
     
     	/*将要发送的第二个字节数据（即要读取的MPU6050内部寄存器的地址）写入发送寄存器*/
     	I2C5.I2CDS = addr;
     	/*清除中断挂起标志位  开始下一个字节的发送*/
     	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
     	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
     	while(!(I2C5.I2CCON & (1<<4)));
     
     	/*清除中断挂起标志位  重新开始一次通信  改变数据传送方向*/
     	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
     
     	/*将第一个字节的数据写入发送寄存器  即从机地址和读写位（MPU6050-I2C地址+读位1）*/
     	I2C5.I2CDS = slave_addr << 1 | 0x01;
     	/*设置IIC为主机接收模式  发送起始信号  使能IIC收发*/
     	I2C5.I2CSTAT = 0xb0;
     	/*等待从机接收到数据后应答*/
     	while(!(I2C5.I2CCON & (1<<4)));
     
     
     	/*禁止主机应答信号（即开启非应答  因为只接收一个字节）  清除中断标志位*/
     	I2C5.I2CCON = I2C5.I2CCON & (~(1<<7))&(~(1<<4));
     	/*等待接收从机发来的数据*/
     	while(!(I2C5.I2CCON & (1<<4)));
     	/*将从机发来的数据读取*/
     	data = I2C5.I2CDS;
     
     	/*直接发起停止信号结束本次通信*/
     	I2C5.I2CSTAT = 0x90;
     	/*清除中断挂起标志位*/
     	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
     	/*延时等待停止信号稳定*/
     	mydelay_ms(10);
     
     	return data;
     
     }
     
     
     /**********************************************************************
      * 函数功能：MPU6050初始化
     **********************************************************************/
     
     void MPU6050_Init ()
     {
     	iic_write(SlaveAddress, PWR_MGMT_1, 0x00); 		//设置使用内部时钟8M
     	iic_write(SlaveAddress, SMPLRT_DIV, 0x07);		//设置陀螺仪采样率
     	iic_write(SlaveAddress, CONFIG, 0x06);			//设置数字低通滤波器
     	iic_write(SlaveAddress, GYRO_CONFIG, 0x18);		//设置陀螺仪量程+-2000度/s
     	iic_write(SlaveAddress, ACCEL_CONFIG, 0x0);		//设置加速度量程+-2g
     }
     
     
     
     /**********************************************************************
      * 函数功能：主函数
      **********************************************************************/
     
     int main(void)
     {
     
     	unsigned char zvalue_h,zvalue_l;						//存储读取结果
     	short int zvalue;
     
     	/*设置GPB_2引脚和GPB_3引脚功能为I2C传输引脚*/
     	GPB.CON = (GPB.CON & ~(0xF<<12)) | 0x3<<12;			 	//设置GPB_3引脚功能为I2C_5_SCL
     	GPB.CON = (GPB.CON & ~(0xF<<8))  | 0x3<<8;				//设置GPB_2引脚功能为I2C_5_SDA
     
     	uart_init(); 											//初始化串口
     	MPU6050_Init();											//初始化MPU6050
     
     	printf("\n********** I2C test!! ***********\n");
     	while(1)
     	{
     		zvalue_h = iic_read(SlaveAddress, GYRO_ZOUT_H);		//获取MPU6050-Z轴角速度高字节
     		zvalue_l = iic_read(SlaveAddress, GYRO_ZOUT_L);		//获取MPU6050-Z轴角速度低字节
     		zvalue  =  (zvalue_h<<8)|zvalue_l;					//获取MPU6050-Z轴角速度
     
     		printf(" GYRO--Z  :Hex: %d	\n", zvalue);			//打印MPU6050-Z轴角速度
     		mydelay_ms(100);
     	}
     	return 0;
     }
     ```

     



## SPI 总线

1. SPI 简介 （串行，高速，全双工，同步）（主从，一对多，4根线）（比串口，IIC快一个级别，但不及USB，网口）

   - > ![image-20220317160603261](assets/image-20220317160603261.png)

2. 寻址方式

   - > ![image-20220317162146659](assets/image-20220317162146659.png)

3. 通信过程

   - 没有起始信号，没有结束信号，没有应答，直接发数据

   - SPICLK下降沿主机发数据，上升沿主机接收数据

   - MSB最高位，LSB最低位，指8位数据的高低位

   - > ![image-20220317162520581](assets/image-20220317162520581.png)

4. 极性和相位

   - > ![image-20220317164441084](assets/image-20220317164441084.png)
     >
     > ![image-20220317164458247](assets/image-20220317164458247.png)
     >
     > ![image-20220317164520297](assets/image-20220317164520297.png)
     >
     > ![image-20220317164530932](assets/image-20220317164530932.png)
     >
     > ![image-20220317164539858](assets/image-20220317164539858.png)

   - > ![image-20220317164547923](assets/image-20220317164547923.png)

5. IIC 和 SPI 的异同 （IIC布线简单，SPI通信快，但需要更多的硬件资源）

   - > ![image-20220317164619519](assets/image-20220317164619519.png)





## SPI 详解 - 参考博主文章

参考博主博客文章 http://www.linuxer.vip/i2c-bus-spec2/

相比 I2C 接口，SPI 接口的通信速度很快。

I2C 和 SPI 的速率如下：

I2C 速率：
标准：100KHz
快速：400KHz
快速+：1MHz
高速：3.4MHz

SPI 速率： 几十 MHz 甚至上百 MHz，速度取决于 CPU 的 SPI 控制器和时钟 clock

STM32F103 的 SPI 最高支持 18MHz，imx6ull 的 SPI 最高支持 52MHz，其他芯片一般用不到更高的。

具体采用多大速率还和外设有关，比如 EEPROM 的 W25Q128 的 SPI 最高支持 80MHz，ICM20608 传感器的 SPI 最高支持8MHz。

因此，I2C 多用来传输命令和重要数据，SPI 用来传输大量数据。

SPI 接口主要应用在 EEPROM，FLASH，实时时钟，AD 转换器，还有数字信号处理器和数字信号解码器之间。

SPI 全称是 SerialPerripheral Interface，也就是串行外围设备接口。SPI 是 Motorola 公司推出的一种同步串行接口技术，是一种高速、全双工的同步通信总线。SPI 以主从方式工作，通常是有一个主设备和一个或多个从设备，一般 SPI 需要4 根线，但是也可以使用三根线(单向传输)，本文我们讲解标准的 4 线 SPI，这四根线如下：

①、**CS/SS**，Slave Select/Chip Select，这个是片选信号线，用于选择需要进行通信的从设备。I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机设备，直接将相应的从机设备片选信号拉低即可。
②、**SCK**，Serial Clock，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟。
③、**MOSI/SDO**，Master Out Slave In/Serial Data Output，简称主出从入信号线，这根数据线只能用于主机向从机发送数据，也就是主机输出，从机输入。
④、**MISO/SDI**，Master In Slave Out/Serial Data Input，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出。

![查看源图像](assets/300px-spi_three_slaves.svg.png)

![img](assets/image-49.png)

SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：
①、CPOL=0，串行时钟空闲状态为低电平。
②、CPOL=1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议。
③、CPHA=0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。
④、CPHA=1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。

示例波形图如下：

![img](assets/image-50-1024x522.png)

**以 CPOL=0，CPHA=0 为例**，SPI 进行全双工通信的时序如图所示：

![img](assets/image-51-1024x473.png)

SPI 的时序图很简单，不像 I2C 那样还要分为读时序和写时序，因为 SPI 是全双工的，所以读写时序可以一起完成。图中，CS 片选信号先拉低，选中要通信的从设备，然后通过 MOSI 和 MISO 这两根数据线进行收发数据，MOSI 数据线发出了0XD2 这个数据给从设备，同时从设备也通过 MISO 线给主设备返回了 0X66 这个数据。

![img](assets/image-1024x663.png)

从图中可以看出，主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存器写入一个字节来发起一次传输。寄存器通过 MOSI 信号线将字节传送给从机，从机也将自己的移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中的内容就被交换。外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。

SPI 主要特点有：可以同时发出和接收串行数据；可以当作主机或从机工作；提供频率可编程时钟；发送结束中断标志；写冲突保护；总线竞争保护等。

虽然 SPI 四线制支持读写同时进行，但实际上我们很多时候并不需要又读又写，见以下两种情况（参考 BMA223 数据手册）：

1、主机向从机写数据

![img](assets/image-1-1024x556.png)

主机发送先发送 8 bits，第一个 bit 代表这次主机是想读还是想写，然后 AD6-AD0 表示读写的寄存器地址。比如这次是写，那么主机就会一直写下去。在这期间 SDO 一直没用，一直是高阻态，因此算是三线制。

2、主机从从机读数据

![img](assets/image-2-1024x574.png)

这种情况下，主机先发送 8 bits，第一位代表这次是读，然后 AD6 – AD0 是想要读的寄存器地址，然后 SDO 开始返回数据。





## I2C 详解 - 参考博主文章

参考博主博客文章 http://www.linuxer.vip/i2c-bus-spec2/

**I2C Introduction**

I2C：Inter-Integrated Circuit，集成电路总线。由 Philips 公司在 1982 年为主机板、嵌入式系统开发的一种简单、双向二线制同步串行总线。 Philips 半导体事业部就是现在的 NXP。

2006 年 11 月，I2C 的专利已经到期，大家可以免费使用。

I2C 是一种低速、串行总线，有 SDA(串行数据线) 和 SCL(串行时钟线) 两条信号线。速度可分为四档：

标准（ST）：0~100KHz，10us per bit 。

快速（FS）：100K~400KHz，10 us~2.5 us per bit。

快速plus：up to 1MHz

高速（HS）：up to 3.4 MHz，~294ns per bit。

![img](assets/image-16.png)

**速度由 SCL 线决定。**

I2C 特性如下：

1、I2C 是一种多主多从的结构，SPI是一主多从。
2、I2C 的读和写都由 master 端发起。
3、I2C 每传输一个byte(8 bit)，都需要 slaver 端回应 ACK/NACK 作为响应。
4、slaver 端通过设备地址区分，有 7 bit 地址和 10bit 地址之分，常用 **7bit 地址+读写位** 来表示。

![img](assets/image-9.png)

SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。后面会教大家如何计算上拉电阻阻值。

**1、起始位**

顾名思义，也就是 I2C 通信起始标志，通过这个起始位就可以告诉 I2C 从机，“我”要开始进行 I2C 通信了。在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位：

![img](assets/image-10.png)

**2、停止位**

停止位就是停止 I2C 通信的标志位，和起始位的功能相反。在 SCL 位高电平的时候，SDA出现上升沿就表示为停止位：

![img](assets/image-11.png)

**3、数据传输**

I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生：

![img](assets/image-12.png)

**4、应答信号**

当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。

**5、I2C 写时序**

主机通过 I2C 总线与从机之间进行通信不外乎两个操作：写和读，I2C 总线单字节写时序如图：

![img](assets/image-13-1024x181.png)

写时序的具体步骤：

1)、开始信号。
2)、发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 I2C 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位，为1 的话表示这是一个读操作，为 0 的话表示这是一个写操作。
3)、 I2C 器件地址后面跟着一个读写位，为 0 表示写操作，为 1 表示读操作。
4)、从机发送的 ACK 应答信号。
5)、重新发送开始信号。
6)、发送要写写入数据的寄存器地址。
7)、从机发送的 ACK 应答信号。
8)、发送要写入寄存器的数据。
9)、从机发送的 ACK 应答信号。
10)、停止信号。

**6、I2C 读时序**

I2C 总线单字节读时序如图：

![img](assets/image-14-1024x168.png)

I2C 单字节读时序比写时序要复杂一点，读时序分为 4 大步，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 I2C 从器件输出要读取的寄存器值，我们具体来看一下这步。

1)、主机发送起始信号。
2)、主机发送要读取的 I2C 从设备地址。
3)、读写控制位，因为是向 I2C 从设备发送数据，因此是写信号。
4)、从机发送的 ACK 应答信号。
5)、重新发送 START 信号。
6)、主机发送要读取的寄存器地址。
7)、从机发送的 ACK 应答信号。
8)、重新发送 START 信号。
9)、重新发送要读取的 I2C 从设备地址。
10)、读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据。
11)、从机发送的 ACK 应答信号。
12)、从 I2C 器件里面读取到的数据。
13)、主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。
14)、主机发出 STOP 信号，停止 I2C 通信。

**7、I2C 多字节读写时序**

有时候我们需要读写多个字节，多字节读写时序和单字节的基本一致，只是在读写数据的时候可以连续发送多个自己的数据，其他的控制时序都是和单字节一样的。



http://www.linuxer.vip/i2c-bus-spec2/

I2C 总线能挂多少设备？

理论上：
7-bit address ：2 的 7 次方，能挂 128 个设备。
10-bit address ：2 的 10 次方，能挂 1024 个设备。

当然，要把预留设备地址去除，7 bit 协议规定了 8个预留地址，厂商不可以使用。保留地址如下：

![img](assets/image-15.png)

但是I2C协议规定，总线上的电容不可以超过 400pF。管脚都是有输入电容的，PCB上也会有寄生电容，所以会有一个限制。实际设计中经验值大概是不超过8个器件。

总线之所以规定电容大小是因为，I2C 使用的GPIO为开漏结构，要求外部有电阻上拉，电阻和总线电容产生了一个 RC 延时效应，**电容越大信号的边沿就越缓**，有可能带来信号质量风险。

传输速度越快，信号的窗口就越小，上升沿下降沿时间要求更短更陡峭，所以 RC 乘积必须更小。

**I2C 架构**

![img](assets/image-17-1024x355.png)

我们知道I2C有不同的速度模式，标准（100KHz）、快速（400KHz）、快速plus（1MHz）采用的GPIO都是开漏模式，支持线与，但是开漏模式无法输出高电平，所以需要外部有上拉，接一个电阻然后接Vdd。

Vdd可以采用 5V、3.3V、1.8V等，电源电压不同，上拉电阻阻值也不同。

一般总线上认为，低于0.3Vdd为低电平，高于0.7Vdd为高电平。

关于为什么GPIO开漏模式支持线与，无法输出高电平，我在GPIO系列文章写过：

[gpio subsystem（1） – linuxer](http://www.linuxer.vip/gpio-subsystem-hardware/)

**线与，是I2C协议的基础！！！！**

线与：当总线上只要有一个设备输出低电平，整条总线便处于低电平状态，这时候总线被称为占用状态。

**上拉电阻计算**

1、上拉电阻过小，电流增大，端口输出低电平增大。

2、上拉电阻过大，上升沿时间增大，方波可能会变成三角波。

因此计算出一个精确的上拉电阻阻值是非常重要的。

计算上拉电阻的阻值，是有明确计算公式的：

![img](assets/image-18.png)

![img](assets/image-19.png)

最大电阻和上升沿时间 tr 、总线电容 Cb 、标准上升沿时间 0.8473 有关。

最小电阻和电源Vdd电压、GPIO口自己最大输出电压 Vol、 GPIO口自己最大电流 Vol 有关。

查《I2C-bus specification and user manual.pdf》7.1节：

![img](assets/image-21.png)

![img](assets/image-27.png)

查《I2C-bus specification and user manual.pdf》表10：

![img](assets/image-20-1024x601.png)

1、标准模式：0~100KHz，上升沿时间 tr = 1us

2、快速模式：100~400KHz，上升沿时间 tr = 0.3us

3、高速模式：up to 3.4MHz，上升沿时间 tr = 0.12us

由此公式，假设 Vdd 是 1.8V 供电，Cb总线电容是200pF（虽然协议规定负载电容最大400pF，实际上超过200pF波形就很不好，我们以200pF来计算）

标准模式 ：

![img](assets/image-23-1024x118.png)

快速模式：

![img](assets/image-24-1024x116.png)

高速模式：

![img](assets/image-25-1024x122.png)

最小电阻（Vdd越大，上拉电阻就要越大）：

![img](assets/image-26-1024x135.png)

注意，高速模式下，电源电压一般采用 1.8 V，不会采用 3.3V，因为如果用 3.3V 计算你会发现最小电阻比最大电阻大。

采用合适的电源电压和合适的上拉电阻，才会让你的 I2C 传输信号最优。

大家在不同速率采用的电阻一般有以下几种：1.5K、2.2K、4.7K。

![img](assets/image-28.png)

一般很少会用到 高速模式（HS），因为这种模式协议比较复杂，既然要快不如用 SPI 了。





## UART、I2C、SPI、TTL、RS232、RS422、RS485、CAN、USB、SD卡、1-WIRE、Ethernet 介绍 - 文章

**UART通用异步收发器**

  UART口指的是一种物理接口形式(硬件)。

![图片](assets/640.jpeg)

  UART是异步，全双工串口总线。它比同步串口复杂很多。有两根线，一根TXD用于发送，一根RXD用于接收:[STM32与51单片机串口通信实例](http://mp.weixin.qq.com/s?__biz=MzI1MDg4OTMwMw==&mid=2247499138&idx=2&sn=58df8f8295a3f4a5df7bea41c546c6fd&chksm=e9f9e8bade8e61ac9e074b8acc16c7e5f6af97e64ac61e374fc691c34c65e6054298630ec26f&scene=21#wechat_redirect)。

  UART的串行数据传输不需要使用时钟信号来同步传输，而是依赖于发送设备和接收设备之间预定义的配置。

  对于发送设备和接收设备来说，两者的串行通信配置应该设置为完全相同。

![图片](assets/640-16494152946541.jpeg)

  起始位：表示数据传输的开始，电平逻辑为“0” 。

  数据位：可能值有5、6、7、8、9，表示传输这几个bit 位数据。一般取值为8，因为一个ASCII 字符值为8 位。

  奇偶校验位：用于接收方对接收到的数据进行校验，校验“1” 的位数为偶数(偶校验) 或奇数(奇校验)，以此来校验数据传送的正确性，使用时不需要此位也可以。

  停止位：表示一帧数据的结束。电平逻辑为“1”。

  如果用通用IO口模拟UART总线，则需一个输入口，一个输出口。

**I2C总线**

  I2C总线是一种同步、半双工双向的两线式串口总线。它由两条总线组成：串行时钟线SCL和串行数据线SDA。

  SCL线——负责产生同步时钟脉冲。

  SDA线——负责在设备间传输串行数据。

  该总线可以将多个I2C设备连接到该系统上。连接到I2C总线上的设备既可以用作主设备，也可以用作从设备。

![图片](assets/640-16494152946542.jpeg)

  主设备负责控制通信，通过对数据传输进行初始化，来发送数据并产生所需的同步时钟脉冲。从设备则是等待来自主设备的命令，并响应命令接收。

  主设备和从设备都可以作为发送设备或接收设备。无论主设备是作为发送设备还是接收设备，同步时钟信号都只能由主设备产生。

  如果用通用IO口模拟I2C总线，并实现双向传输，则需一个输入输出口(SDA)，另外还需一个输出口(SCL)。

**SPI串行外设接口**

  SPI总线是同步、全双工双向的4线式串行接口总线。它是由“单个主设备+多个从设备”构成的系统。

  在系统中，只要任意时刻只有一个主设备是处于激活状态的，就可以存在多个SPI主设备。常运用于AD转换器、EEPROM、FLASH、实时时钟、数字信号处理器和数字信号解码器之间实现通信。

![图片](assets/640-16494152946543.jpeg)

  为了实现通信，SPI共有4条信号线，分别是：

- 主设备出、从设备入（Master Out Slave In，MOSI）：由主设备向从设备传输数据的信号线，也称为从设备输入（Slave Input/Slave Data In，SI/SDI）。
- 主设备入、从设备出（Master In Slave Out，MISO）：由从设备向主设备传输数据的信号线，也称为从设备输出（Slave Output/Slave Data Out，SO/SDO）。
- 串行时钟（Serial Clock，SCLK）：传输时钟信号的信号线。
- 从设备选择（Slave Select，SS）：用于选择从设备的信号线，低电平有效。

  SPI       的工作时序模式由CPOL（Clock Polarity，时钟极性）和CPHA（Clock Phase，时钟相位）之间的相位关系决定，CPOL       表示时钟信号的初始电平的状态，CPOL 为0 表示时钟信号初始状态为低电平，为1 表示时钟信号的初始电平是高电平。CPHA       表示在哪个时钟沿采样数据，CPHA 为0 表示在首个时钟变化沿采样数据，而CPHA 为1 则表示在第二个时钟变化沿采样数据。

![图片](assets/640-16494152946554.jpeg)

**UART、SPI、I2C比较**

- I2C线更少，比UART、SPI更为强大，但是技术上也更加麻烦些，因为I2C需要有双向IO的支持，而且使用上拉电阻，抗干扰能力较弱，一般用于同一板卡上芯片之间的通信，较少用于远距离通信。
- SPI实现要简单一些，UART需要固定的波特率，就是说两位数据的间隔要相等，而SPI则无所谓，因为它是有时钟的协议。
- I2C的速度比SPI慢一点，协议比SPI复杂一点，但是连线也比标准的SPI要少。
- UART一帧可以传5/6/7/8位，I2C必须是8位。I2C和SPI都从最高位开始传。
- SPI用片选信号选择从机，I2C用地址选择从机。

![图片](assets/640-16494152946555.jpeg)

**RS232串口通信**

  传输线有两根，地线一根。电平是负逻辑：

  -3V~-15V逻辑“1”，+3V~+15V逻辑“0”:[简述TTL、RS232、RS485电平标准](http://mp.weixin.qq.com/s?__biz=MzUzODM0MDI0MQ==&mid=2247494089&idx=4&sn=714f6e687904cd965e31d160abe5118a&chksm=fadb9737cdac1e21fd18f42e783ef5587973b6317f9edee8a1f620164cc0492cf1671440eeeb&scene=21#wechat_redirect)。

  RS-232串口通信传输距离15米左右。可做到双向传输，全双工通讯，传输速率低20kbps 。

  下图是DB9公头和母头的定义，一般用的最多的是RXD、TXD、GND三个信号。

![图片](assets/640-16494152946556.jpeg)

  **TTL和RS-232互转**

  单片机接口一般是TTL电平，如果接232电平的外设，就需要加TTL转RS232的模块。如下图，可用芯片MAX232进行转换。

![图片](assets/640-16494152946557.png)

**RS422串口通信**

  RS-422有4根信号线：两根发送、两根接收和一根地线，是全双工通信。

  它有一个主设备，其余为从设备，从设备之间不能通信，所以RS-422支持点对多的双向通信。

![图片](assets/640-16494152946558.png)

**RS485串口通信**

  RS-485采用平衡发送和差分接收，因此具有抑制共模干扰的能力。

  采用两线半双工传输，最大速率10Mb/s，电平逻辑是两线的电平差来决定的，提高抗干扰能力，传输距离长(几十米到上千米)。

  +2V~+6V逻辑“1”，-2~-6V逻辑“0”。

  TTL转成RS-485很常见，比如MAX485，参考电路如下

![图片](assets/640-16494152946569.jpeg)

  RE引脚：接收器输出使能（低电平有效）。

  DE引脚：发送器输出使能（高电平有效）。可以直接通过MCU的IO端口控制。

**TTL**

  嵌入式里面说的串口，一般是指UART口。4个pin（Vcc,GND,RX,TX），用TTL电平。

  PC中的COM口即串行通讯端口，简称串口。9个Pin，用RS232电平。

![图片](assets/640-164941529465610.jpeg)

  串口、COM口是指的物理接口形式(硬件)。而TTL、RS-232、RS-485是指电平标准(电信号)。

![图片](assets/640-164941529465611.jpeg)

  单片机与PC通讯示意图如下：

![图片](assets/640-164941529465712.jpeg)

**CAN总线**

  CAN是控制器局域网络的简称，是一种能够实现分布式实时控制的串行通信网络。CAN总线的功能复杂且智能。主要用于汽车通信。

  CAN总线网络主要挂在CAN_H和CAN_L，各个节点通过这两条线实现信号的串行差分传输，为了避免信号的反射和干扰，还需要在CAN_H和CAN_L之间接上120欧姆的终端电阻。

![图片](assets/640-164941529465713.jpeg)

  每一个设备既可做主设备也可做从设备。CAN总线的通信距离可达10千米（速率低于5Kbps），速度可达1Mbps（通信距离小于40M）。

![图片](assets/640-164941529465714.jpeg)



**CAN电平逻辑**

  CAN总线采用"线与"的规则进行总线冲裁，1&0为0，所以称0为显性，1为隐性。

  从电位上看，因为规定高电位为0，低电位为1，同时发出信号时实际呈现为高电位，从现象上看就像0覆盖了1，所以称0为显性，1为隐性。

![图片](assets/640-164941529465715.jpeg)

**USB通信串行总线**

  USB接口最少有四根线，其中有两根是数据线，而所有的USB数据传输都是通过这两根线完成。它的通信远比串口复杂的多。

  两根数据线采用差分传输，即需要两根数据线配合才能传输一个bit，因此是半双工通信，同一时间只能发送或者接收。

  USB 规定，如果电压电平不变，代表逻辑1；如果电压电平变化，则代表逻辑0。

![图片](assets/640-164941529465716.jpeg)

**USB转TTL**

  一般USB转串口都是用CH340G芯片。

![图片](assets/640-164941529465717.jpeg)

  用串口通信比USB简单，因为串口通信没有协议。

**SD卡**

  SD卡是一种存储卡，可用于手机作为内存卡使用。

  嵌入式中，单片机与SD卡通信有两种模式：

- SPI总线通信模式
- SD总线通信模式

![图片](assets/640-164941529465718.jpeg)

  值得注意的是，SD总线模式中有4条数据线；SPI总线模式中仅有一条数据线（MOSI和MISO不能同时读数据，也不能同时写数据）；这样在嵌入式中，单片机与SD卡通信时采用SD总线模式比SPI总线模式速度快几倍。

[![图片](assets/640-164941529465819.jpeg)](https://mp.weixin.qq.com/s/rl4xzzsInZXyrNJ1qEvprw)

**1-WIRE总线**

  1-Wire由美国Dallas(达拉斯)公司推出，是一种异步半双工串行传输。采用单根信号线，既传输时钟又传输数据，而且数据传输是双向的。

![图片](assets/640-164941529465920.jpeg)

  单总线的数据传输速率一般为16.3Kbit/s，最大可达142 Kbit/s，通常情况下采用100Kbit/s以下的速率传输数据。

  1-Wire线端口为漏极开路或三态门的端口，因此一般需要加上拉电阻Rp，通常选用5K~10KΩ

  主要应用在：打印墨盒或医疗消耗品的识别；印刷电路板、配件及外设的识别和认证。

**DMA直接存储器访问**

  DMA是STM32内的一个硬件模块，它独立于CPU，在外围设备和内存之间进行数据传输，解放了CPU，可使CPU的效率大大提高。

![图片](assets/640-164941529465921.jpeg)

  它可以高速访问外设、内存，传输不受CPU的控制，并且是双向通信。因此，使用DMA可以大大提高数据传输速度，这也是ARM架构的一个亮点——DMA总线控制。

  DMA就相应于一条高速公路，专用、高速的特性。如果不使用DMA，也可以达到目的，只是达到目的的时间比较长。

**Ethernet以太网**

  以太网是目前应用最普遍的局域网技术。

  大家知道，以太网接口可分为协议层和物理层。

  协议层是由一个叫MAC(Media Access Layer)控制器的单一模块实现。

  物理层由两部分组成，即PHY(Physical Layer)和传输器。

  目前很多主板的南桥芯片已包含了以太网MAC控制功能，只是未提供物理层接口。因此，需外接PHY芯片以提供以太网的接入通道。

![图片](assets/640-164941529465922.jpeg)

  网络变压器的作用是：

- 耦合差分信号，抗干扰能力更强
- 变压器隔离网线端不同设备的不同电平，隔离直流信号

  以太网接口参考电路，如下图所示。

![图片](assets/640-164941529465923.jpeg)













































































































