## C 头文件 - HQ

[TOC]

------

#### 注意

- 

------

## 嵌入式C语言编程——.h文件与.c文件

**.h文件与.c文件的关系**

参考高手的程序时，发现别人写的严格的程序都带有一个“KEY.H”，里面定义了.C文件里用到的自己写的函数，如Keyhit()、Keyscan()等。.H文件就是头文件，估计就是Head的意思吧，这是规范程序结构化设计的需要，既可以实现大型程序的模块化，又可以实现根各模块的连接调试。

**.H文件介绍：**

  在单片机嵌入式C程序设计中，项目一般按功能模块化进行结构化设计。将一个项目划分为多个功能，每个功能的相关程序放在一个C程序文档中，称之为一个模块，对应的文件名即为模块名。一个模块通常由两个文档组成，一个为头文件*.h，对模块中的数据结构和函数原型进行描述;另一个则为C文件*.c ，对数据实例或对象定义，以及函数算法具体实现。

**.H文件的作用**

作为项目设计，除了对项目总体功能进行详细描述外，就是对每个模块进行详细定义，也就是给出所有模块的头文件。通常H头文件要定义模块中各函数的功能，以及输入和输出参数的要求。模块的具体实现，由项目组成根据H文件进行设计、编程、调试完成。为了保密和安全，模块实现后以可连接文件OBJ、或库文件LIB的方式提供给项目其他成员使用。由于不用提供源程序文档，一方面可以公开发行，保证开发人员的所有权;另一方面可以防止别人有意或无意修改产生非一致性，造成版本混乱。所以H头文件是项目的详细设计和团队工作划分的依据，也是对模块进行测试的功能说明。要引用模块内的数据或算法，只要用包含include指定模块H头文件即可。

**.H文件的基本组成**

```
/*如下为键盘驱动的头文档*/
#ifndef _KEY_H_ //防重复引用，如果没有定义过_KEY_H_，则编译下句
#define _KEY_H_ //此符号唯一， 表示只要引用过一次，即#i nclude，则定义符号_KEY_H_
/////////////////////////////////////////////////////////////////

char keyhit( void ); //击键否

unsigned char Keyscan( void ); //取键值

/////////////////////////////////////////////////////////////////
#endif
```

**尽量使用宏定义#define**

开始看别人的程序时，发现程序开头，在文件包含后面有很多#define语句，当时就想，搞这么多标示符替换来替换去的，麻不麻烦啊，完全没有理解这种写法的好处。原来，用一个标示符表示常数，有利于以后的修改和维护，修改时只要在程序开头改一下，程序中所有用到的地方就全部修改，节省时间。

```
#define KEYNUM 65//按键数量，用于Keycode[KEYNUM]
#define LINENUM 8//键盘行数
#define ROWNUM 8//键盘列数
```

  注意的地方：

- 宏名一般用大写
- 宏定义不是C语句，结尾不加分号

**不要乱定义变量类型**

以前写程序，当需要一个新的变量时，不管函数内还是函数外的，直接在程序开头定义，虽然不是原则上的错误，但是很不可取的作法。下面说一下，C语言中变量类型的有关概念。从变量的作用范围来分，分为局部变量和全局变量：

- 全局变量：是在函数外定义的变量，全局变量在程序全部执行过程中都占用资源，全局变量过多使程序的通用性变差，因为全局变量是模块间耦合的原因之一。
- 局部变量：在函数内部定义的变量，只在函数内部有效。

  从变量的变量值存在的时间分为两种：

- 静态存储变量：程序运行期间分配固定的存储空间。
- 动态存储变量：程序运行期间根据需要动态地分配存储空间。

  具体又包括四种存储方式：

- auto
- static
- register
- extern

不加说明默认为auto型，即动态存储，如果不赋初值，将是一个不确定的值。而将局部变量定义为static型的话，则它的值在函数内是不变的，且初值默认为0。编译时分配为静态存储区，可以被本文件中的各个函数引用。如果是多个文件的话，如果在一个文件中引用另外文件中的变量，在此文件中要用extern说明。不过如果一个全局变量定义为static的话，就只能在此一个文件中使用。register定义寄存器变量，请求编译器将这个变量保存在CPU的寄存器中，从而加快程序的运行。

**特殊关键字const volatile的使用**

**const**

  const用于声明一个只读的变量。

```
const unsigned char a=1;//定义a=1，编译器不允许修改a的值
```

  作用：保护不希望被修改的参数。

**volatile**

一个定义为volatile的变量是说这变量可能会被意想不到地改变,这样,编译器就不会去假设这个变量的值了。精确地说就是,优化器在用到这个变量时必须每次都小心地重新读取这个变量的值,而不是使用保存在寄存器里的备份。

```
static int i=0;
int main(void)
{
...
while (1)
{
if (i)
dosomething();
}
}
/* Interrupt service routine. */
void ISR_2(void)
{
i=1;
}
```

程序的本意是希望ISR_2中断产生时，在main当中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作,然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将将变量加上volatile修饰,则编译器保证对此变量的读写操作都不会被优化(肯定执行)。

  一般说来,volatile用在如下的几个地方：

- 中断服务程序中修改的供其它程序检测的变量需要加volatile；
- 多任务环境下各任务间共享的标志应该加volatile；
- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义。































