## 关键字volatile - HQ

[TOC]

------

#### 注意

- 文章参考：https://blog.csdn.net/tigerjibo/article/details/7427366

------

### 引入背景：编译器优化

硬件级别的优化：由于内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。

再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器进行优化。

编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏解决编译器的执行顺序问题。

```c
void Barrier(void)
```

这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。

所以volatile总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以消除一些代码。**但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化。**



### volatile详解

volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。

当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。

精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。

> 简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错

看两个事例：

- 告诉compiler不能做任何优化：比如要往某一地址送两指令

```c
int *ip =...; //设备地址
*ip = 1; //第一个指令
*ip = 2; //第二个指令
```

以上程序compiler可能做优化而成：

```c
nt *ip = ...;
*ip = 2;
```

结果第一个指令丢失。如果用volatile, compiler就不允许做任何的优化，从而保证程序的原意：

```c
volatile int *ip = ...;
*ip = 1;
*ip = 2;
```

即使你要compiler做优化，它也不会把两次付值语句间化为一。它只能做其它的优化。

- 用volatile定义的变量会在程序外被改变,每次都必须从内存中读取，而不能重复使用放在cache或寄存器中的备份

```c
volatile char a;
a=0;
while(!a){

//do some things;

}

doother();
```

如果没有 volatiledoother()不会被执行。

- 下面是使用volatile变量的几个场景：

- - 中断服务程序中修改的供其它程序检测的变量需要加volatile；

```c
static int i=0;

int main(void)
{
     ...
     while (1)
     {
        if (i) dosomething();
     }
｝
/* Interrupt service routine. */
void ISR_2(void)
{
      i=1;
}
```

程序的本意是希望ISR_2中断产生时，在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。

- ==多任务环境下各任务间共享的标志应该加volatile（这个在Linux应用编程里面会使用到）==
- ==存储器映射的硬件寄存器通常也要加voliate，因为每次对它的读写都可能有不同意义。==比如：假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000

```c
int  *output = (unsigned  int *)0xff800000;//定义一个IO端口；

int   init(void)
{
      int i;
      for(i=0;i< 10;i++)
      {
         *output = i;
      }
}
```

经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，所以编译器最后给你编译编译的代码结果相当于：

```c
int  init(void)
{
      *output = 9;
}
```

如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。

```c
volatile  int *output=(volatile unsigned int *)0xff800000;//定义一个I/O端口
```

另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中禁止任务调度，3中则只能依靠硬件的良好设计。



### 问题解答

- 一个参数既可以是const还可以是volatile吗？

  - 可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

- 一个指针可以是volatile 吗？

  - 可以，当一个中服务子程序修该一个指向一个buffer的指针时。

- volatile的本质：

- - 编译器的优化:在本次线程内, 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值；当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致。**当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。**当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致。
  - volatile应该解释为“直接存取原始内存地址”比较合适，“易变的”这种解释简直有点误导人。

- 下面的函数有什么错误：?

```c
int square(volatile int *ptr)
{
   return *ptr * *ptr;
}
```

该程序的目的是用来返指针`*ptr`指向值的平方，但是，由于`*ptr`指向一个volatile型参数，编译器将产生类似下面的代码：

```c
int square(volatile int *ptr)
{
   int a,b;

   a = *ptr;

   b = *ptr;

   return a * b;
}
```

由于`*ptr`的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

```c
long square(volatile int *ptr)
{
    int a;
    a = *ptr;
    return a * a;
}
```

**注意：频繁地使用volatile很可能会增加代码尺寸和降低性能,因此要合理的使用volatile。**





































































































































































